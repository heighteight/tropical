%Recall the two approaches with more details on lambda-calculus and on existing challenges.


%In this section, we discuss in some more detail the two approaches to quantitative semantics we mentioned in the Introduction, at the same time providing an overview of how we aim at bridging them using tropical mathematics.

\paragraph*{Metric approach: bounded $\lambda$-calculus in a nutshell}

On the one hand one there is the approach of \emph{program metrics} \cite{Reed2010, Gaboardi2017, Gabo2019} and \emph{quantitative equational theories} \cite{Plotk}: when considering probabilistic or approximate computation, rather than asking whether two programs compute \emph{the same} function, it makes more sense to ask whether they compute functions which do not differ \emph{too much} by controlling the propagation of an error during the computation.
This has motivated the study of denotational frameworks in which types are endowed with a metric, measuring similarity of behavior; this approach has found  applications in e.g.~differential privacy \cite{Reed2010} and coinductive methods \cite{Bonchi2018}, and was recently extended to account for the full $\lambda$-calculus \cite{Geoffroy2020, PistoneLICS, PistoneFSCD2022}.
%As already mentioned, in many situations (e.g.~when dealing with computationally difficult problems, or in differential privacy \cite{Alvim2011, Reed2010}), one %does not look for algorithms to compute a function \emph{exactly}, but rather to approximate it (in an efficient way) within some error bound. In other common situations (e.g.~in differential privacy \cite{Alvim2011, Reed2010}) one needs to verify that an algorithm is not \emph{too sensitive} to errors, that is, a small error in the input will produce a comparably small error in the output. 
%In all these cases, it is common to consider forms of denotational semantics in which types are endowed with a \emph{behavioral metric}, that is, a metric on programs which account for differences in behavior. 
A fundamental insight coming from this line of work is that \emph{affine} programs, i.e.~programs that may use their input at most once, correspond to \emph{non-expansive} (or $1$-Lipschitz) maps, that is, to functions $f$ for which the distances
$d(f(x),f(y))$ produced in output are bounded by the distances $d(x,y)$ in input. 
This is due to the fact that the category $\Met$ of pseudo-metric spaces and non-expansive maps provides a model of the %\emph{linear} simply typed $\lambda$-calculus, being a \emph{symmetric monoidal closed} category, and in fact it also models 
\emph{affine} $\lambda$-calculus (it is symmetric monoidal closed, cartesian and monoidal units coincide). 
The metric approach is not restricted to affine programs, but can be extended to programs with \emph{bounded} duplications \cite{Reed2010, Gaboardi2017}: the idea is that a program duplicating its input $K$ times will give rise to a $K$-\emph{Lipschitz} map.
For instance, the higher-order program $M=\lambda f.\lambda x.f(f(x))$, which duplicates the function input $f$, yields a $2$-Lipschitz map between the metric space $\BB R\multimap \BB R$ of non-expansive real functions and itself. %: if $f,g$ are two non-expansive maps differing by at most $\epsilon$ (i.e.~for which $|f(x)-g(x)|\leq \epsilon$ holds for all $x\in \BB R$), then the application of $M$ to $f$ and $g$ will produce two maps differing by at most $2\epsilon$. 
By observing that a $r$-Lipschitz map between metric spaces $X$ and $Y$ is the same as a non-expansive map between the \emph{re-scaled} space $rX:=(X,%d_{r}(x,y)=
rd(x,y))$ and $Y$, the program $M$ above 
can thus be interpreted as a non-expansive map from $2(\BB R\multimap \BB R)$ to $\BB R\multimap \BB R$.

These observations have led to the study of linear $\lambda$-calculi with \emph{graded} exponentials, like $\mathsf{Fuzz}$ \cite{Reed2010}, inspired from Girard's Bounded Linear Logic \cite{Girard92tcs}, which have been applied to the study of differential privacy \cite{Gaboardi2013, Gaboardi2017}. The types of such systems are defined by combining linear constructors with a \emph{graded linear exponential comonad} $!_{r}(-)$ \cite{Katsumata2018}.
The language $\BSTLC$ we consider is a simplified version of the language $\mathrm{Fuzz}$ \cite{Reed2010}. 
The terms are as for the $\STLC$, the types are $A::= * \ \mid  \ !_{n}A \multimap A$ and type judgements are of the form $\Gamma \vdash M:A$, where a context $\Gamma$ is a set of declarations of the form $x :_{n}A$, with $n\in \mathbb N$.
The typing rules are given in Fig.~\ref{fig:rules}, where $\Gamma+\Delta$ is defined letting $(\Gamma, x:_{m} A)+( \Delta, x:_{n} A) =  (\Gamma+\Delta), x:_{m+n}A$, and $m\Gamma$ is made all $x:_{mn}A$ for $(x:_{n}A) \in \Gamma$.  
The axiom is $x:_{1}A\vdash x: A$.
The main feature of this language is that if $\vdash \lambda x.M:\,!_nA\multimap B$, then $x$ will be duplicated exactly $n$ times in the reduction to the normal form. %, i.e.\ $\vdash \lambda x.M:\,!_nA\multimap B$ is a program which performs $n$ duplications.
E.g., $\vdash_{\BSTLC} \lambda {\color{red}z}.\left( \lambda x{\color{green}y}. yxx \right)z : \, !_{\color{red}2} *\multimap !_{\color{green}1}(!_{\color{violet}1} * \multimap !_{\color{blue}1} * \multimap *) \multimap *$.
The $\BSTLC$ can be interpreted in a symmetric monoidal closed category (SMCC) equipped with a \emph{$\mathbb N$-graded linear exponential comonad} \cite{Katsumata2018}.
%Observe that one can always type an affine term like e.g.~$\lambda xy.x$ with a linear type $A\multimap B\multimap A$. Instead, a term like $\lambda xy.x(xy)$ containing two occurrences of $x$ cannot be given the linear type $(A\multimap A)\multimap (A\multimap A)$ but a type of the form
%$!_{2}(A\multimap A)\multimap (A\multimap A)$. 

\begin{figure*}

	\scriptsize
	
	\[ \arraycolsep=5pt\def\arraystretch{2.8}
	\begin{array}{cccc}
		\prooftree
		\Gamma \vdash M:A
		\justifies
		\Gamma, x:_{0}B \vdash M:A
		\endprooftree 
		&
		\prooftree
		\Gamma, x:_{n}B, y:_{m} B\vdash M:A
		\justifies
		\Gamma, x:_{n+m}B\vdash M\{x/y\}:A
		\endprooftree 
		&
		\prooftree
		\Gamma, x:_{n} A\vdash M: B
		\justifies
		\Gamma\vdash \lambda x.M: !_{n}A\multimap B
		\endprooftree
		&
		\prooftree
		\Gamma \vdash M: !_nA\multimap B
		\quad
		\Delta\vdash N: A
		\justifies
		\Gamma +n\Delta\vdash MN: B
		\endprooftree
		\\
		\\
		\hline
		\\
		\prooftree
		\Gamma, x: A\vdash M: B
		\justifies
		\Gamma\vdash \lambda x.M: A\to B
		\endprooftree 
		&
		\prooftree
		\Gamma \vdash M: A\to B
		\quad
		\Gamma\vdash \mathbb T: A
		\justifies
		\Gamma \vdash M\mathbb T: B
		\endprooftree 
		&
		\prooftree
		\Gamma \vdash M: A\to B
		\quad
		\Gamma \vdash N: A
		\justifies
		\Gamma \vdash \Diff{M}{N}: A\to B
		\endprooftree
		&
		\prooftree
		\Gamma\vdash M_1: A
		\,\cdots\,
		\Gamma \vdash M_n:A
		\justifies
		\Gamma \vdash M_1+\cdots +M_n : A
		\using (n\geq 2)
		\endprooftree
	\end{array}
	\]
	\caption{Typing rules (axiom rules are given in the text) for $\BSTLC$ (top) and $\STDLC$ (bottom).}\label{fig:rules}
\end{figure*}


\paragraph*{Resource approach: differential $\lambda$-calculus in a nutshell}

On the other hand, there is the approach based on \emph{differential} \cite{difflambda} or \emph{resource-aware} \cite{Boudol1993} extensions of the $\lambda$-calculus, which is well-connected to the so-called \emph{relational semantics} \cite{Manzo2012, Manzo2013, dill} and has a syntactic counterpart in the study of \emph{non-idempotent} intersection types \cite{decarvalho2018, Mazza2016}. This family of approaches have been exploited to account for higher-order program differentiation \cite{difflambda}, to establish reasonable \emph{cost-models} for the $\lambda$-calculus \cite{Accattoli2021}, and have also been shown suitable for the probabilistic setting \cite{Manzo2013, Breuvart2018, PistoneLICS2022}. 

%A different family of approaches to linearity and duplication arises from the study of the \emph{differential $\lambda$-calculus} \cite{difflambda} (and differential linear logic \cite{dill}) and its categorical models. 
The key ingredient is a \emph{differential operator} $\Der$,  added to the usual syntax of the $\lambda$-calculus. The intuition is that, given $M$ of type $A\to B$ and $N$ of type $A$, the program $\Diff{M}{N}$, still of type $A\to B$, corresponds to the \emph{linear application} of $M$ to $N$: this means that $N$ is passed to $M$ so that the latter may use it exactly once (this is why $\Diff{M}{N}$ still has type $A\to B$, since $M$ might need \emph{other} copies of an input of type $A$). 

The syntax of the differential $\lambda$-calculus $\STDLC$ (e.g.\ \cite[Section 3]{Manzo2010}), is given by the \emph{terms} $M$ and the \emph{sums} $\mathbb T$, mutually generated by: $M::= x\mid \lambda x.M \mid M\mathbb T \mid \Diff{M}{M}$ and $\mathbb T::= 0 \mid M \mid M+\mathbb T$,
quotiented by: $\alpha$-equivalence; $+,0$ form a commutative monoid on the set of sums; %, i.e.\ commutativity and associativity of $+$ and neutrality of $0$ w.r.t.\ $+$;
linearity of $\lam x.(\_)$, $\Diff{\_}{\_}$ and $(\_)\mathbb T$ (but \emph{not} of $M(\_)$); irrelevance of the order of consecutive $\Diff{\_}{\_}$.
%Remark that $M(\_)$ is \emph{not} set to be linear: $\lambda x.0=0\mathbb T=\Diff{0}{N}=\Diff{M}{0}=0$ but $M0\neq0$ in general.
%This is crucial for the definition of the Taylor expansion.
We follow the tradition of quotienting also for the idempotency of $+$.
%Sums are, then, just \emph{finite} sets of terms.
Simple types are $A::= *\mid A\to A$.
The typing system is in Figure~\ref{fig:rules}, where a context $\Gamma$ is a list of typed variable declarations.
The axioms are $\Gamma, x:A \vdash x: A$ and $\Gamma\vdash 0:A$.

%In $\BSTLC$ the typing system handles duplications; in $\STDLC$ the syntax with its operational semantics (that we do not give) does it.
Writing $\Der^2[\_,(\_)^2]$ as a shortcut for $\Der[\Der[\_,\_],\_]$ and $\Der^1[\_,(\_)^1]$ for $\Diff{\_}{\_}$, the analogue of the previous $\BSTLC$-term is $\vdash_{\STDLC} \lambda {\color{red}z}. \Der^{\color{red}2}[
	\lambda x{\color{green}y}.
		\Der^{\color{violet}1} [
				\Der^{\color{blue}1} [y, x^{\color{blue}1}]
        0, x^{\color{violet}1}
	]0
, z^{\color{red}2}]0
: {\color{red}*}\to ({\color{green}* \to * \to *}) \to *$.
%Here we wrote $\Der^2[\_]\cdot (\_)^2$ as a shortcut for $\Der[\Der[\_]\cdot (\_)]\cdot (\_)$ and $\Der^1[\_]\cdot (\_)^1$ for $\Der[\_]\cdot (\_)$.
In particular, if the \emph{multiplicities} of the arguments (the colored exponents) do not exactly match the number of duplications, e.g.\ in $\vdash_{\STDLC} \lambda z. \Der^{\color{red}3}[
	\lambda xy.
		\Diff{
				\Diff{y}{x}
		0}{x}
	0
, z^{\color{red}3}]0
: *\to (* \to * \to *) \to *$, then the term reduces to the empty sum $0$ (representing an \emph{error}).

%Correspondingly, the syntax of the simply typed \emph{differential} $\lambda$-calculus ($\STDLC$) is defined by enriching $\STLC$ with a monoid structure $0,+$ over terms, as well as with $\Der$ and a notion of \emph{linear substitution} (see \cite{difflambda} or the Appendix for details).
%The models of $\STDLC$ are the cartesian \emph{closed} differential categories ($CC\partial C$), which are defined as $C\partial C$ which are also cartesian closed, and in which the monoid structure and the differential operator are both well-behaved with respect to the closed structure \cite{Manzo2012}. 

The $\STDLC$ can be interpreted in Cartesian closed differential $\lambda$-categories (CC$\partial\lambda$C)\cite{Manzo2010,Blute2009, Blute2019}.
In them, homsets are equipped with a structure of commutative monoid %(i.e.\ we can add morphisms and there is a $0$ morphism)
%, it is Cartesian closed%(with the closed structure compatible with the additive structure)
and with a certain \emph{differential operator} $D$, generalising the usual notion of differentiation, see e.g.\ \cite{BluteEhrhTass10}.
%An example is the CC$\partial\lambda$C of convenient vector spaces with smooth maps, where $D$ is the ``real'' differential $Df:\mathbb{V}\times\mathbb{V}\rightarrow \mathbb{W}$, $Df(x,u):=\dfrac{d}{dt}{\!\Big|_{t=0}} f(x+tu)$, of smooth maps $f:\mathbb{V}\rightarrow \mathbb{W}$.
%More precisely, a cartesian category $\C C$ is a $C\partial C$ when:
%\begin{itemize}
%\item $\C C$ is left-additive, i.e.~its hom-sets have the structure of commutative monoids, and the cartesian structure is well-behaved w.r.t.~this monoid structure;
%\item $\C C$ is equipped with a differential operator $D:
%\C C(X,Y)\to \C C(X\times X,Y)$ satisfying some axioms which capture usual properties of differentials (e.g.~the linearity of $D$ in one of its two variables, the chain rule, etc.).
%\end{itemize}

Another intriguing similarity between program derivatives and 
actual derivatives is provided by the \emph{Taylor expansion} $\C T$:
%In analysis, a sufficiently regular function can be seen (locally around a point) as its Taylor expansion, i.e.\ a series of polynomials weighted via some rational coefficient.
%Now, a polynomial in $x$ of degree $k$ can be thought of as a function which uses its argument $x$ exactly $k$ times.
in $\STDLC$ (even untyped), we can perform a syntactic Taylor expansion of an ordinary $\lambda$-term via an inductively defined map $\Theta$ giving rise to an infinite series of terms, whose crucial case of the definition is
$
\Theta(MN)=\sum_{n\in\mathbb{N}}\frac{1}{n!}\Der^n\left[\Theta(M),\Theta(N)^n\right]0.
$
As in analysis, it decomposes an application as a series of $k$-linear functions, which can be seen as its approximants.
In other words, unbounded duplications correspond to some sort of limit of bounded, but arbitrarily large, ones.
Since we only consider idempotent sum, the factorial coefficient disappears, and the resulting Taylor map is called the \emph{qualitative} Taylor expansion, indicated by $\Te{\_}$.
% (this perspective is made clearer by the related approach of the \emph{resource $\lambda$-calculus} \cite{}).

%More formally, the differential operator $\Der[-]$ transforms a function $M:A\to B$ into a function $\Der[M]: A\to (A\to B)$ which is linear in its first argument. 
%Since $M$ may rather ask for several copies of $N$, this requires a form of non-determinism: 
%For example, if $M$ is the term $\lambda fx.f(fx)$ considered before, $\Der[M]$ takes a first input $N$ and passes it linearly to $M$. Notice that there are two ways of doing so, corresponding to the two bound occurrences of $f$ in $M$: either by applying $N$ to $fx$, or by 
%applying $f$ linearly to $Nx$ (indeed, if $f$ were applied in an unrestricted way, it might duplicate $Nx$, so that $N$ would not be used linearly). This justifies the equation below, in which $\Der[M]$ is identified with the non-deterministic sum of the two possible linear choices:
%\begin{align}
%\Der\left[\lambda f x.f(fx)\right]\cdot N = 
%\lambda fx. N(fx) + \left(\Der[f]\cdot (Nx)\right)(fx)
%\end{align}
%More generally, one can define a notion of $k$-bounded application $\Der^{(k)}[M]\cdot N^{k}$, where $\Der^{(0)}[M]\cdot N^{0}= M$ and $\Der^{(k+1)}[M]\cdot N^{k+1}= \Der[ \Der^{(k)}[M]\cdot N^{k}]\cdot N$, corresponding to passing $N$ to $M$ exactly $k$ times.
%
%
%The name ``differential'' for the operator $\Der[-]$ is justified by the fact that it satisfies many properties of the usual differential operator of analysis $\Der[f]:= \lambda xy. \frac{\mathsf df(y)}{\mathsf dy}\cdot x$. Notably, it is additive in its first variable (i.e.~it commutes with the non-deterministic sum operator), and satisfies the chain rule.
%Most famously, the differential operator can be used to define a Taylor formula for $\lambda$-terms, which decomposes an unrestricted application into a formal non-deterministic sum of bounded applications:

%
%More generally, the relational semantics interprets unbounded programs as \emph{analytic functions}, that is, as functions admitting a representation as power series. For instance, observing that an analytic map $f: \BB R\to \BB R$, where $f(x)=\sum_{n}\widehat f_{n}\cdot x^{n}$ is uniquely determined by the sequence $\widehat f_{n}$, the program $M_{\infty}:=\lambda fx.fx: (\BB R\To \BB R)\To (\BB R\To \BB R)$ is represented by the power series below:
%\begin{align}
%F_{\infty}(f,x)= \sum_{n=0}^{\infty} \widehat f_{n} x^{n}
%\end{align}
%By restricting ourselves to bounded applications, the terms in the power series become finite, that is, the interpretation becomes a \emph{polynomial}: for instance, the program $M_{2}:=\lambda fx. \sum_{i=0}^{2}\Der^{(i)}[f]\cdot x^{i}$, corresponding to passing $x$ \emph{at most twice} to $f$, is represented by the polynomial
%\begin{align}
%F_{\leq 2}(f,x)=\widehat f_{2} x^{2}  + \widehat f_{1}x +  \widehat f_{0} 
%\end{align}
% In this framework the differential operator is naturally represented by formal differentiation of polynomials, where, as one would expect, 
% $\Der[\sum_{n}a_{n}x^{n}]=\sum_{n}\Der[a_{n}x^{n}]$ and $\Der[a_{0}x^{0}]=0$ and $\Der[a_{n+1}x^{n+1}]= (n+1)a_{n+1}x^{n}$, so that power series can be Taylor expanded. 





 
